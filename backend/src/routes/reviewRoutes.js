/**
 * Review Routes
 * 
 * Caretaker endpoints for reviewing, approving, and rejecting
 * memory and identity proposals generated by learning sessions.
 */

import { healthCheck as ragHealth } from '../services/ragClient.js';
import logger from '../utils/logger.js';

/**
 * Register review routes on the Fastify server.
 * @param {import('fastify').FastifyInstance} server
 */
export default async function reviewRoutes(server) {

    /**
     * GET /api/reviews
     * List pending reviews for the authenticated user.
     * Requires caretaker role.
     */
    server.get('/api/reviews', {
        preHandler: [server.authenticate],
    }, async (request, reply) => {
        try {
            const userId = request.user.id || request.user._id;

            // Forward to RAG engine (which queries review_queue)
            const axios = (await import('axios')).default;
            const ragUrl = process.env.RAG_ENGINE_URL || 'http://localhost:8081';

            // For now, we'll use a direct search — the Go service doesn't have
            // a dedicated list-reviews endpoint yet, so we use the MongoDB fallback
            // This will be improved when the Go service gets a reviews endpoint
            const { default: mongoose } = await import('mongoose');
            const db = mongoose.connection.db;

            if (!db) {
                return reply.code(503).send({ success: false, message: 'Database not available' });
            }

            const reviews = await db.collection('review_queue')
                .find({ user_id: userId.toString(), status: 'pending' })
                .sort({ created_at: -1 })
                .toArray();

            return reply.send({
                success: true,
                reviews: reviews || [],
                count: reviews?.length || 0,
            });
        } catch (err) {
            logger.error('Error listing reviews:', err.message);
            return reply.code(500).send({ success: false, error: err.message });
        }
    });

    /**
     * POST /api/reviews/:sessionId/approve
     * Approve a review — commits proposed memories and identity updates.
     */
    server.post('/api/reviews/:sessionId/approve', {
        preHandler: [server.authenticate],
    }, async (request, reply) => {
        try {
            const { sessionId } = request.params;
            const userId = request.user.id || request.user._id;
            const { default: mongoose } = await import('mongoose');
            const db = mongoose.connection.db;

            if (!db) {
                return reply.code(503).send({ success: false, message: 'Database not available' });
            }

            // Find the review
            const review = await db.collection('review_queue').findOne({
                session_id: sessionId,
                user_id: userId.toString(),
            });

            if (!review) {
                return reply.code(404).send({ success: false, message: 'Review not found' });
            }

            if (review.status !== 'pending') {
                return reply.code(400).send({ success: false, message: `Review already ${review.status}` });
            }

            // Commit proposed memories via RAG engine
            const { storeMemory } = await import('../services/ragClient.js');
            const commitResults = [];

            if (review.proposed_memories?.length) {
                for (const mem of review.proposed_memories) {
                    const result = await storeMemory(
                        userId.toString(),
                        mem.content,
                        mem.importance || 0.5,
                        mem.source || 'conversation',
                        sessionId
                    );
                    commitResults.push(result);
                }
            }

            // Update review status
            await db.collection('review_queue').updateOne(
                { session_id: sessionId },
                { $set: { status: 'approved', reviewed_at: new Date() } }
            );

            logger.info(`Review ${sessionId} approved by user ${userId} — committed ${commitResults.length} memories`);

            return reply.send({
                success: true,
                sessionId,
                committed: commitResults.length,
                message: 'Review approved and memories committed',
            });
        } catch (err) {
            logger.error('Error approving review:', err.message);
            return reply.code(500).send({ success: false, error: err.message });
        }
    });

    /**
     * POST /api/reviews/:sessionId/reject
     * Reject a review — discards all proposals.
     */
    server.post('/api/reviews/:sessionId/reject', {
        preHandler: [server.authenticate],
    }, async (request, reply) => {
        try {
            const { sessionId } = request.params;
            const userId = request.user.id || request.user._id;
            const { default: mongoose } = await import('mongoose');
            const db = mongoose.connection.db;

            if (!db) {
                return reply.code(503).send({ success: false, message: 'Database not available' });
            }

            const result = await db.collection('review_queue').updateOne(
                { session_id: sessionId, user_id: userId.toString() },
                { $set: { status: 'rejected', reviewed_at: new Date() } }
            );

            if (result.matchedCount === 0) {
                return reply.code(404).send({ success: false, message: 'Review not found' });
            }

            logger.info(`Review ${sessionId} rejected by user ${userId}`);

            return reply.send({
                success: true,
                sessionId,
                message: 'Review rejected',
            });
        } catch (err) {
            logger.error('Error rejecting review:', err.message);
            return reply.code(500).send({ success: false, error: err.message });
        }
    });

    /**
     * GET /api/reviews/health
     * Check RAG engine health from the Node side.
     */
    server.get('/api/reviews/health', async (request, reply) => {
        const health = await ragHealth();
        return reply.send(health);
    });
}
